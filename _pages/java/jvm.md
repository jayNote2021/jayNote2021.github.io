---
layout: categories
permalink: /java/jvm/
---
# 1장. java JVM이란? 그리고 JVM구조

---

### References

- [https://gbsb.tistory.com/2](https://gbsb.tistory.com/2)
- [https://preamtree.tistory.com/2](https://preamtree.tistory.com/2)]

### 같이 보면 좋은 페이지

- [기본적인 번역기의 종류](https://www.notion.so/7-d16d880d85ad4768a7abc5e2e00f41f0)
- [자바 번역기의 특징](https://www.notion.so/8-02e012545a614452b0d59047c8d9afde)

---

# index

- [자바 프로그램 구동 과정]()
- [자바 가상 머신(JVM : JAVA Virtual Machine)]()
- [자바 가상 머신의 구성]()

---

# 자바 프로그램 구동 과정

1. 소스코드를 작성한다. (.java 확장자의 소스파일)
2. 컴파일러(javac.exe)가 컴파일하여 바이트 코드로 변환한다. (.class 확장자의 클래스 파일)
3. 런처(java.exe)로 자바 가상 머신(JVM)을 구동한다.
4. 자바 가상 머신이 바이트코드(.class)를 해석하여 자바 프로그램이 실행 된다.

** 바이트코드(bytecode)는 자바 가상 머신이 이해할 수 있는 언어로 변환된 코드다. 자바 가상 머신만 설치되어 있다면 바이트코드는 어떤 운영체제에서라도 실행될 수 있다.

- 위의 구동과정 예시
    1. **TestCode.java : 자바 컴파일 규약에 따라 작성한 소스코드**

        ![1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled.png)

        → 문법이 잘못되면 컴파일 과정에서 에러를 내보낸다.

    2. **javac.exe 실행 :  javac.exe를 통해 TestCode.java 컴파일 실행**

        ![1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%201.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%201.png)

        → 위의 명령어를 통해 TestCode.class 파일 생성

    3. **TestCode.class : javac.exe에 의해 컴파일된 바이트 코드 생성**

        ![1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%202.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%202.png)

        → 바이트 코드는 일반적인 방법으로 내용을 볼 수 없다.

    4. **java.exe : java.exe로 자바 가상머신을 구동하고 TestCode.class를 실행한다.**

        ![1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%203.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%203.png)

        → java.exe ${파일명} 명령을 실행시 .class는 생략한다.

---

# 자바 가상 머신(JVM : JAVA Virtual Machine)

### 가상 머신이란?

프로그램을 실행하기 위한 물리적인 머신과 유사한 머신을 소프트웨어로 구현한 것이다. 

→  jvm에 대한 자세한 설명 [여기(JVM이란 무엇인가?)](https://www.itworld.co.kr/news/110837) 클릭

**일반적인 프로그램(.exe)은 OS(운영체제)가 프로그램을 실행**시킨다.

반면 자바 프로그램을 실행하면 운영체제가 JVM을 실행시키고 JVM이 프로그램(.class)를 실행한다.

그래서 말 그대로 JVM은 .class로 된 프로그램을 실행하는 "가상의 머신"이다.

![1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%204.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%204.png)

즉, 자바 프로그램의 클래스 파일(.class)들은 운영체제에서 직접 동작하는 것이 아니라 

"JVM"에서 동작한다. 그래서 윈도우에서 개발한다면 윈도우용 JVM을 설치하고 

맥에서 개발한다면 맥용 JVM을 설치하면 된다. 

사용자가 어떠한 운영체제를 사용하더라도 운영체제에 맞는 JVM만 설치되어 있다면

.class로 된 프로그램은 실행이 가능하다.

이는 C/C++ 언어와는 대조되며, 이러한 것을 "**플랫폼 독립성, 이식성이 높다**"고 한다.

다만, 플랫폼 독립성에 따라 운영체제에 맞는 가상 머신을 설치해야 하므로 운영체제에 종속적이다. 

그리고 자바 프로그램은 한 단계를 더 거쳐야 하므로 C/C++로 만들어진 프로그램 보다 상대적으로

실행 속도가 느리다는 단점이 있다.

**그래도 JVM의 발전에 따라서 비슷한 성능을 보이며, 특정 환경에서는 더 빠르기도 하다.

---

# 자바 가상 머신의 구성

![1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%205.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20java%20JVM%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20JVM%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20d6b21c0dd72e4d2891fd8a98dc6f3c9f/Untitled%205.png)

### 클래스 로더(Class Loader)

런타임에 **클래스 파일들을 JVM 내부로 로딩하고 분석**한 뒤에 각각 **Runtime Data Areas에 배치**한다. 

자바는 동적으로 클래스를 읽어오므로([동적 로딩](https://futurists.tistory.com/43?category=550970)) 런타임 시점에서야 모든 코드가 JVM과 연결된다.

### 실행 엔진(Execution Engine)

Runtime Data Areas에 배치된 **바이트코드를 해석하며 실행**한다.

이 때 인터프리터 방식과, JIT 컴파일 방식을 혼합하여 해석한다.

- 인터프리터(Interperter) 방식 :

    → 바이트코드를 한 줄씩 일고 해석한다.

- JIT 컴파일(Just - In - Time Compile) 방식 :

    → 바이트코드를 런타임 시점에서 바로 기계어로 변환한다.

    → 자세한 설명은 [여기](https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC) 클릭

** 최초의 가상 머신은 인터프리터 방식만 써서 실행 속도가 느렸지만, JIT 컴파일 방식을 추가하여 이를 보완하고자 했다. 그런데 JIT 컴파일은 바이트코드를 기계어로 바꾸기 때문에 실행 속도가 빠르지만 변환하는 데 비용이 발생하게 된다. 그래서 인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 JIT 컴파일 방식으로 실행한다.

### 런타임 데이터 영역(Runtime Data Areas)

런타임 데이터 영역은 **JVM이 사용하는 메모리 영역**이다. 

JVM이 실행시 OS에게 할당 받고 클래스 로더에서 분석된 클래스 파일의 데이터를 저장한다.

그리고 실행 도중에 사용되는 데이터를 저장한다. 

**메모리를 효율적으로 관리하기 위해 크게 5가지 영역으로 나누어 사용한다.**

1. **스태틱 영역(메서드 영역)** : class 데이터
2. **힙영역** : 객체 데이터
3. **스택 영역** : 스레드 별로 생성, 기본형 데이터 타입 저장
4. **PC 레지스터 :** JVM이 수행할 명령어의 주소를 저장하는 공간
5. **네이티브 메서드 스택** : C/C++로 작성된 코드를 수행하기 위해 사용

### 가비지 컬렉터(Garbage Collector)

java는 프로그램 메모리 관리를 개발자가 아닌 JVM에게 위임하였다.

그래서 **JVM은 GC를 통해 메모리 관리 기능을 자동으로 수행**한다. 

더 이상 사용하지 않는 객체를 해제시켜 메모리를 자동으로 반납한다.

---
